package dx.compiler

import java.nio.file.{Files, Path}

import dx.api.{DxApi, DxApp, DxApplet, DxFindApps, DxFindDataObjects, DxPath, DxProject}
import dx.core.getVersion
import wdlTools.util.FileUtils

abstract class DxNativeInterface(dxApi: DxApi) {
  def getApplet(dxProject: DxProject, path: String): DxApplet = {
    path match {
      case id if id.startsWith("applet-") => dxApi.applet(id)
      case _ =>
        val fullPath = s"${DxPath.DX_URL_PREFIX}/${path}"
        dxApi.resolveOnePath(fullPath, Some(dxProject)) match {
          case applet: DxApplet => applet
          case _                => throw new Exception(s"DxNI only supports apps and applets")
        }
    }
  }

  private def searchApplets(dxProject: DxProject,
                            folder: String,
                            recursive: Boolean): Vector[DxApplet] = {
    val applets: Vector[DxApplet] =
      DxFindDataObjects(dxApi)
        .apply(Some(dxProject),
               Some(folder),
               recursive,
               classRestriction = Some("applet"),
               withInputOutputSpec = true)
        .keySet
        .collect {
          case applet: DxApplet if applet.describe().properties.exists(_.contains(CHECKSUM_PROP)) =>
            applet
        }
        .toVector
    if (applets.isEmpty) {
      dxApi.logger.trace(s"Found no applets in project ${dxProject.id}/${folder}")
    }
    applets
  }

  private def searchApps: Vector[DxApp] = {
    val apps: Vector[DxApp] = DxFindApps(dxApi)
      .apply(published = Some(true), withInputOutputSpec = true)
    if (apps.isEmpty) {
      dxApi.logger.warning(s"Found no DX global apps")
    }
    apps
  }
  def writeToFile(doc: Vector[String], outputPath: Path, force: Boolean): Unit = {
    if (Files.exists(outputPath)) {
      if (!force) {
        throw new Exception(
            s"""|Output file ${outputPath.toString} already exists,
                |use -force to overwrite it""".stripMargin
              .replaceAll("\n", " ")
        )
      }
      outputPath.toFile.delete
    }
    FileUtils.writeFileContent(outputPath, doc.mkString("\n"))
  }

  private def appletsHeader(dxProject: DxProject, folderOrPath: Either[String, String]) = Vector(
      s"This file was generated by the Dx Native Interface (DxNI) tool ${getVersion}.",
      s"project name = ${dxProject.describe().name}",
      s"project ID = ${dxProject.getId}",
      s"folder = ${folderOrPath.merge}"
  )

  def generateApplets(applets: Vector[DxApplet],
                      headerLines: Vector[String]): Option[Vector[String]]

  def applyApplets(dxProject: DxProject,
                   folderOrPath: Either[String, String],
                   output: Path,
                   recursive: Boolean,
                   force: Boolean): Unit = {
    val applets: Vector[DxApplet] = folderOrPath match {
      case Left(folder) => searchApplets(dxProject, folder, recursive)
      case Right(path)  => Vector(getApplet(dxProject, path))
    }
    if (applets.nonEmpty) {
      val doc = generateApplets(applets, appletsHeader(dxProject, folderOrPath))
      if (doc.isDefined) {
        writeToFile(doc.get, output, force)
      }
    }
  }

  val appsHeader = Vector(
      s"This file was generated by the Dx Native Interface (DxNI) tool ${getVersion}.",
      "These are interfaces to apps."
  )

  def generateApps(apps: Vector[DxApp], headerLines: Vector[String]): Option[Vector[String]]

  def applyApps(output: Path, force: Boolean): Unit = {
    val apps = searchApps
    if (apps.nonEmpty) {
      val doc = generateApps(apps, appsHeader)
      if (doc.isDefined) {
        writeToFile(doc.get, output, force)
      }
    }
  }

  def generateAppsAndApplets(apps: Vector[DxApp],
                             applets: Vector[DxApplet],
                             headerLines: Vector[String]): Option[Vector[String]]

  def apply(dxProject: DxProject,
            folderOrPath: Either[String, String],
            output: Path,
            recursive: Boolean,
            force: Boolean): Unit = {
    val apps = searchApps
    val applets: Vector[DxApplet] = folderOrPath match {
      case Left(folder) => searchApplets(dxProject, folder, recursive)
      case Right(path)  => Vector(getApplet(dxProject, path))
    }
    val doc = generateAppsAndApplets(apps, applets, appletsHeader(dxProject, folderOrPath))
    if (doc.isDefined) {
      writeToFile(doc.get, output, force)
    }
  }
}
